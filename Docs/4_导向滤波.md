# 导向滤波

很早以前就听说导向滤波（Guided Filter）的大名，但是一直对其原理都不甚了解。直到最近在做一些图像融合的项目，发现很多文章都基于导向滤波，因此决定好好阅读一下原理，争取掌握。



## 背景

如Gaussian、Laplacian、Sobel等很多传统图像滤波器，滤波器与图像内容之间是相互独立的，滤波时对图像内的所有像素都进行相同的运算，这常常会导致滤除噪声的同时也抹去了图像的细节，增强图像细节的时候又增强了图像噪声。

为了使滤波器和图像内容更好的结合，研究人员提出使用导向图（Guidance Image）来建立滤波器。如常用的双边滤波，就是都根据导向图色彩相似性对局部像素进行加权得到新的像素值，然而双边滤波可能会出现一些梯度反转伪影（Gradient Reversal Artifacts）。

于是，何凯明大神和他的大神伙伴们就研究啊研究，最后提出了导向滤波。



## 原理

### 1. 基本假设和损失函数

在定义导向滤波器之前，首先要明确其最关键的假设是：导向滤波器是导向图$I$和滤波输出$q$之间的局部线性模型。即是：
$$
q_i=a_kI_i+b_k, \forall i \in w_k
$$
在图像的局部窗口$w_k$中，$a_k$和$b_k$都是常量系数。对局部线性模型求导即有$\nabla q = a \nabla I$，所以输出图$q$中的边缘信息都来自且仅来自导向图$I$，也正如此，导向滤波才可以起到保留边缘细节的作用。

为了确定线性系数使得输出图$q$和输入图$p$之间的差异最小化，我们使用均方误差（Mean Square Error）来定量局部窗口内的损失函数：
$$
E(a_k,b_k)=\sum_{i \in w_k}[(a_kI_i+b_k-p_i)^2 + \epsilon a_k^2]
$$
这里的$\epsilon$是为了防止系数$a_k$过大而设置的正则化系数。到这里，了解过统计机器学习的就恍然大明白了，这不就是$L_2$正则化的线性模型求解吗？为了使文章更易读，这里还是解一下这个损失函数的最优解。



### 2. 线性模型求解

首先对上式求偏导：
$$
\begin{align}
& \frac{\partial E}{\partial a_k} = 2\sum_{i \in w_k}[Ii(a_kI_i+b_k-p_i) + \epsilon a_k] \\
& \frac{\partial E}{\partial b_k} = 2\sum_{i \in w_k}(a_kI_i+b_k-p_i)
\end{align}
$$
我们知道（假设知道呀），一元二次函数的极值总是在导数为$0$时取得，因此要求最优解时的系数即是求偏导为$0$时的系数。于是：
$$
\begin{align}
&\frac{\partial E}{\partial b_k} = 0 \\
\Longrightarrow &\sum_{i \in w_k}(a_kI_i + b_k - p_i) = 0 \\
\Longrightarrow &b_k=\frac{1}{|w_k|} \sum_{i \in w_k}(p_i - a_kI_i) = \overline{p_k} - a_k \overline{I_k} \\

\\
&\frac{\partial E}{\partial a_k} = 0 \\
\Longrightarrow &\sum_{i \in w_k}[I_i(a_kI_i + b_k - p_i) + \epsilon a_k] = 0 \\
\Longrightarrow &\sum_{i \in w_k}(a_kI_i^2 + b_kI_i - p_iI_i + \epsilon a_k) = 0 \\
\Longrightarrow &\sum_{i \in w_k}a_kI_i^2 = \sum_{i \in w_k}(p_iI_i - b_kI_i - \epsilon a_k) \\
\Longrightarrow &\sum_{i \in w_k}a_kI_i^2 = \sum_{i \in w_k}[p_iI_i - (\overline{p_k} - a_k \overline{I_k})I_i - \epsilon a_k] \\
\Longrightarrow &\sum_{i \in w_k}(a_kI_i^2 + \epsilon a_k - a_k\overline{I_k}I_i)= \sum_{i \in w_k}(p_iI_i - \overline{p_k}I_i) \\
\Longrightarrow & a_k = 
	\frac{\sum_{i \in w_k}(p_iI_i - \overline{p_k}I_i)}
		 {\sum_{i \in w_k}(I_i^2 - \overline{I_k}I_i + \epsilon)} \\
\Longrightarrow & a_k = 
	\frac{\frac{1}{|w_k|}\sum_{i \in w_k}p_iI_i - \overline{p_k}\overline{I_k}} 
    	 {\overline{I_k^2} - \overline{I_k}^2 + \epsilon} \\
\Longrightarrow & a_k = 
	\frac{\frac{1}{|w_k|}\sum_{i \in w_k}p_iI_i - \overline{p_k}\overline{I_k}} 
    	 {\sigma_k^2 + \epsilon} \\

\end{align}
$$



### 3.局部推广全局

如果每个局部窗口都是不重叠，那么输出图像在局部窗口边界肯定会出现块效应，可如果局部窗口是相互重叠的，重叠像素涉及的每个局部窗口都会有一个不同输出像素值！一种简单的处理方法就是对所有输出像素值进行平均，以平均值作为最终的输出像素值。即是：
$$
\begin{align}
q_i &= \frac{1}{|w|}\sum_{k:i \in w_k} a_kI_i+b_k \\
	&= \overline{a_i}I_i+\overline{b_i}
\end{align}
$$
值得注意的是，求平均之后$\nabla q$和$\nabla I$不再成比例，因为还受到局部窗口内其他像素的影响。但是$q$的变化仍然主要受到来自$I$的影响，所以仍有$\nabla q  \approx a \nabla I$。



## 实现

根据上诉原理，这里使用Opencv在C++上进行了实现：

```C++
void guidedFilter(cv::Mat& guidiance, cv::Mat& src, cv::Mat& dst, const int r, float eps)
{
	// Convert to float
	cv::Mat p, I;
	src.convertTo(p, CV_32F);
	guidiance.convertTo(I, CV_32F);

	// Guided Filtering	
	const cv::Size wsz(r, r);
	cv::Mat mean_p, mean_I, mean_Ip, mean_II;
	cv::blur(p, mean_p, wsz);
	cv::blur(I, mean_I, wsz);
	cv::blur(p.mul(I), mean_Ip, wsz);
	cv::blur(I.mul(I), mean_II, wsz);

	cv::Mat a, b, am, bm;
	a = (mean_Ip - mean_p.mul(mean_I)) / (mean_II - mean_I.mul(mean_I) + eps);
	b = mean_p - a.mul(mean_I);
	cv::blur(a, am, wsz);
	cv::blur(b, bm, wsz);

	dst = am.mul(I) + bm;
	dst.convertTo(dst, CV_8U);
}
```



## 效果

上述函数实现效果：

![adobe_4_merge ](../Data/guided_filter/adobe_4_merge .jpg)

可以看到边缘区域的细节被很好的保留了下来，边缘内外区域被平滑了很多。



**参考文献或博客：**

http://kaiminghe.com/publications/eccv10guidedfilter.pdf

图片来源于：https://www.arxiv-vanity.com/papers/1905.06747/，如有侵权，请联系我删除。