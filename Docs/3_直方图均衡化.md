# 直方图均衡化

直方图均衡化是一种经典的图像处理算法，用以改善图像的亮度和对比度。如下图，亮度整体偏暗，灰度值大致分布在较低的范围内（虽然是作者刻意画成这样的(￣▽￣)"）：

![nangongwan_gray](../Data/histogram_equalization/nangongwan_gray.png)

对图像进行直方图均衡化的目的是，使其原本分布集中的像素值，均衡的分布到所有可取值的范围，这样，图像就既有明亮也有灰暗，对比度和亮度就得到了改善。



## 直方图

图像的直方图就是像素值$r_k$出现的总的频数$n_k$，其公式如下：
$$
h(r_k)=n_k,\ k=0,1,2,...L-1
$$
一般情况下，通常将其除以总的像素数，通过概率的形式去表述：
$$
p(r_k)=\frac{h(r_k)}{MN}=\frac{n_k}{MN}
$$


## 全局直方图均衡化

### 1.原理

直方图均衡化可以看作是一种映射，对原图$A$中的像素点施加映射$f$使其转换为图$B$。在直方图均衡化中，我们保持像素值的单调性，即:
$$
\begin{cases}
	q_1=f(p_1) \\ 
	q_2=f(p_2) 
\end{cases}	\\
若p_1<p_2,则q_1<q_2
$$
其中$p_1$和$p2$为$A$中的像素值，$q_1$和$q2$为$B$中的像素值。由$A$和$B$之间的像素值是一一对应且单调的，可以得出：
$$
\int_ph(a)da = \int_qh(b)db
$$
即区间$(p_1,p2)$中的像素数和区间$(q_1,q_2)$中的像素数是相等的。因此，每个对应的像素值的累积概率函数是相等的：
$$
\int_0^ph(a)da = \int_0^qh(b)db
$$
我们希望映射后的图$B$直方图分布是均衡的，即是理想情况下，图$B$中像素值的概率分布是服从均匀分布的，即$h(b)=\frac{MN}{L}$，则：
$$
\int_0^ph(a)da = \frac{q*MN}{L} = \frac{f(p)*MN}{L} \\ 
\Rightarrow 
f(p) = \frac{L}{MN}\int_0^ph(a)da
$$
这样我们就得到了实现均衡化的映射方式。

### 2. C++实现

实现均衡化的代码如下：

```C++
// Statistical histogram
void statHist(const cv::Mat& image, int* hist)
{
	int idx = 0;
	for (int i = 0; i < image.rows; i++)
	{
		for (int j = 0; j < image.cols; j++)
		{
			idx = int(image.at<uchar>(i, j));
			hist[idx]++;
		}
	}
}

// Get map table
void mapTable(const int* hist, const int size, uchar* table)
{
	float factor = 256.f / size;
	int map_value, cumu_num = 0;
	for (int i = 0; i < 256; i++)
	{
		cumu_num += hist[i];
		map_value = int(cumu_num * factor);
		if (map_value > 255) map_value = 255;
		table[i] = uchar(map_value);
	}
}

// Mapping
void map(const cv::Mat& src, const uchar* table, cv::Mat& dst)
{
	src.copyTo(dst);

	for (int i = 0; i < src.rows; i++)
	{
		for (int j = 0; j < src.cols; j++)
		{
			dst.at<uchar>(i, j) = table[(int)src.at<uchar>(i, j)];
		}
	}
}

// Global histogram equlization
void histEqualization(const cv::Mat& src, cv::Mat& dst)
{
	int hist[256] = { 0 };
	uchar table[256] = { 0 };
	statHist(src, hist);
	mapTable(hist, src.rows * src.cols, table);
	map(src, table, dst);
}
```



### 3. 处理效果

从下图中可以看出，全局直方图均衡化确实增强了对比度和亮度，但是得到的效果有些过分亮了，这是因为原图中大多像素值集中于较小的区间内，稍微大一点儿的像素值对应的累积概率都接近1了，映射过后的像素值自然会很亮。除此之外，原本柔和的较暗区域内出现了明显的边缘现象，这是因为原本相邻的相差较小像素，映射后的差值被拉得过大，自然出现边缘效应。为了避免较亮的像素点被过分增强，可以考虑对该像素点周围局部区域进行直方图均衡化，从而不被其他区域较暗的像素点影响。

![nangongwan_globalhe](../Data/histogram_equalization/nangongwan_globalhe.png)



## 局部直方图均衡化

### 1.简单分块直方图均衡化

一种简单的局部直方图均衡化的方法是，直接将图像分为若干$m×m$的小块，每个小块分别进行直方图均衡化。代码如下：

```C++
void localHistEqualization(const cv::Mat& src, cv::Mat& dst, const int m)
{
	// Padding
	const int h = src.rows, w = src.cols;
	const int rdh = h % m, rdw = w % m;
	const int pdh = rdh == 0 ? h : h + m - rdh;
	const int pdw = rdw == 0 ? w : w + m - rdw;
	const int res_h = pdh - h, res_w = pdw - w;
	const int top = res_h / 2, left = res_w / 2;
	const int bottom = res_h - top, right = res_w - left;
    cv::Mat im_pad;
	cv::copyMakeBorder(src, im_pad, top, bottom, left, right, cv::BORDER_DEFAULT);

	// Equalization
	int i = 0, j = 0, ni = m, nj = m;
	while (i < pdh)
	{
		ni = i + m;
		while (j < pdw)
		{
			nj = j + m;
            equalizeHist(im_pad.rowRange(i, ni).colRange(j, nj), im_pad.rowRange(i, ni).colRange(j, nj));
			j = nj;
		}
		i = ni;
		j = 0;
	}
	im_pad.rowRange(top, h + top).colRange(left, w + left).copyTo(dst);
}
```

结果那是稍微有点儿抽象：

![nangongwan_clahe](../Data/histogram_equalization/nangongwan_lhe.png)



### 2.局部自适应直方图均衡化

虽然我还挺喜欢上面这种风格的，但是很明显，直接分为若干小块分别进行直方图均衡化并不是一个好办法。不仅存在一些过度增强，块与块之间还存在非常显著的差异。那如果我们不区分块与块，而是以每个像素为中心，根据其周围$m×m$局部区域对该像素进行直方图均衡化如何？这其实就是局部自适应直方图均衡化。使用此方法，每一个像素都需要计算$m^2$次运算，但是还好每次移动块，只有块的一边出去，一边进来，所以此方法可以加速。不多说了，直接上代码吧：

```C++
void localAdaptiveHistEqualization(const cv::Mat& src, cv::Mat& dst, const int m)
{
	// Padding
	cv::Mat src_pad;
	const int psz = m / 2;
	const int hend = src.rows + psz;
	const int wend = src.cols + psz;
	cv::copyMakeBorder(src, src_pad, psz, psz, psz, psz, cv::BORDER_DEFAULT);
	src.copyTo(dst);

	// Equalization
	int hist[256] = { 0 };
	float factor = 256.f / (m * m);
	int pi = 0, pj = 0, val = 0, cumv = 0;
	for (int i = psz; i < hend; i++)
	{
		for (int j = psz; j < wend; j++)
		{
			if (j == psz)
			{
				// Reset
				for (int pi = 0; pi < 256; pi++)
				{
					hist[pi] = 0;
				}

				// Statistical histogram
				for (pi = i - psz; pi <= i + psz; pi++)
				{
					for (pj = j - psz; pj <= j + psz; pj++)
					{
						val = (int)src_pad.at<uchar>(pi, pj);
						hist[val]++;
					}
				}
			}
			else
			{
				// Pop left
				pj = j - psz - 1;
				for (pi = i - psz; pi <= i + psz; pi++)
				{
					val = (int)src_pad.at<uchar>(pi, pj);
					hist[val]--;
				}

				// Push right
				pj = j + psz;
				for (pi = i - psz; pi <= i + psz; pi++)
				{
					val = (int)src_pad.at<uchar>(pi, pj);
					hist[val]++;
				}
			}
            
            // Equlization
			cumv = 0;
			val = (int)src_pad.at<uchar>(i, j);
			for (pi = 0; pi <= val; pi++)
			{
				cumv += hist[pi];
			}
			dst.at<uchar>(i - psz, j - psz) = uchar(cumv * factor);
		}
	}
}
```

结果如下：

![nangongwan_lahe](../Data/histogram_equalization/nangongwan_lahe.png)

啊这，，，块效应是减轻了不少，可是过度增强的情况还是存在着。此外，即使减少了一些统计直方图时的操作，对图像的每个元素进行操作的计算代价仍然过高。针对这些情况，研究人员提出限制对比度的直方图均衡化方法。



## 限制对比度的直方图均衡化

### 1. 限制对比度的全局直方图均衡化

图像中的像素分布并不均匀，可能存在个别像素值的像素数目特别多，进而使直方图均衡化时比该值更大的像素值被过度增强。因此，可以从这类像素中“挪”出一些平均分配到其他像素中。话不多说，直接上代码：

```C++
void che(const cv::Mat& src, cv::Mat& dst, const float clip_limit)
{
	// Statistical histogram
	const int h = src.rows;
	const int w = src.cols;
	int hist[256] = { 0 };
	uchar table[256] = { 0 };
	statHist(src, hist);

	// Limitation
	int steal = 0;
	const int limit = h * w * clip_limit / 256;
	for (int k = 0; k < 256; k++)
	{
		if (hist[k] > limit)
		{
			steal += hist[k] - limit;
			hist[k] = limit;
		}
	}

	// Hand out the steals averagely
	const int bonus = steal / 256;
	for (int k = 0; k < 256; k++)
	{
		hist[k] += bonus;
	}

	// Get mapping table
	mapTable(hist, h*w, table);

	// Map
	map(src, table, dst);
}
```

结果如下：

![nangongwan_che](../Data/histogram_equalization/nangongwan_che.png)

相比原图对比度被增强了不少，相比全局直方图均衡化对比度被限制了不少，总的来说效果还行。



### 2. 限制对比度的自适应直方图均衡化

同样地，我们也想知道，如果在局部自适应直方图均衡化的基础之上限制对比度会更好吗？动手试试看！前面已经尝试过，使用在局部使用直方图会产生块效应，为了减轻块效应，我们对相邻块之间进行了插值运算。

```C++
void clahe(const cv::Mat& src, cv::Mat& dst, const float clip_limit, const int m)
{
	// Padding
	cv::Mat im_pad;
	const int h = src.rows, w = src.cols;
	const int pdh = minInteger(h, m), pdw = minInteger(w, m);
	const int res_h = pdh - h, res_w = pdw - w;
	const int left = res_w / 2, top = res_h / 2;
	const int right = res_w - left, bottom = res_h - top;
	cv::copyMakeBorder(src, im_pad, top, bottom, left, right, cv::BORDER_DEFAULT);

	// Initialize histogram
	const int hnum = pdh / m;
	const int wnum = pdw / m;
	const int bnum = hnum * wnum;
	int** hists = new int*[bnum];
	float** table = new float* [bnum];
	for (int i = 0; i < bnum; i++)
	{
		hists[i] = new int[256];
		table[i] = new float[256];
		for (int j = 0; j < 256; j++)
		{
			hists[i][j] = 0;
			table[i][j] = 0.f;
		}
	}

	// Statistical histogram, Get mapping table
	const int benum = m * m;
	const int limit = benum * clip_limit / 256;
	int idx = 0, steal = 0, bonus = 0;
	for (int i = 0; i < hnum; i++)
	{
		for (int j = 0; j < wnum; j++)
		{
			// Statistical
			idx = i * wnum + j;
			statHist(im_pad.rowRange(i * m, (i + 1) * m).colRange(j * m, (j + 1) * m), hists[idx]);
			
			// Limitation
			steal = 0;
			for (int k = 0; k < 256; k++)
			{
				if (hists[idx][k] > limit)
				{
					steal += hists[idx][k] - limit;
					hists[idx][k] = limit;
				}
			}

			// Hand out the steals averagely
			bonus = steal / 256;
			for (int k = 0; k < 256; k++)
			{
				hists[idx][k] += bonus;
			}

			// Cumulative --> table
			table[idx][0] = hists[idx][0] * 255.f / benum;
			for (int k = 1; k < 256; k++)
			{
				table[idx][k] = table[idx][k - 1] + hists[idx][k] * 255.f / benum;
			}
		}
	}
	delete[] hists;

	// Equalization and Interpolation
	const int hm = m / 2;
	//im_pad.copyTo(im_pad);
	int hbi = 0, wbi = 0;
	int bidx[4] = { 0 };
	float p = 0.f, q = 0.f;
	for (int i = 0; i < pdh; i++)
	{
		for (int j = 0; j < pdw; j++)
		{
			//four coners  
			if (i <= hm && j <= hm)
			{
				idx = 0;
				im_pad.at<uchar>(i, j) = (uchar)(table[idx][im_pad.at<uchar>(i, j)]);
			}
			else if (i <= hm && j >= pdw - hm)
			{
				idx = wnum - 1;
				im_pad.at<uchar>(i, j) = (uchar)(table[idx][im_pad.at<uchar>(i, j)]);
			}
			else if (i >= pdh - hm && j <= hm)
			{
				idx = bnum - wnum;
				im_pad.at<uchar>(i, j) = (uchar)(table[idx][im_pad.at<uchar>(i, j)]);
			}
			else if (i >= pdh - hm && j >= pdw - hm)
			{
				idx = bnum - 1;
				im_pad.at<uchar>(i, j) = (uchar)(table[idx][im_pad.at<uchar>(i, j)]);
			}
			//four edges except coners -- linear interpolation
			else if (i <= hm)
			{
				// hbi = 0;
				wbi = (j - hm) / m;
				bidx[0] = wbi;
				bidx[1] = bidx[0] + 1;
				p = (float)(j - (wbi * m + hm)) / m;
				q = 1 - p;
				im_pad.at<uchar>(i, j) = (uchar)(q * table[bidx[0]][im_pad.at<uchar>(i, j)] + p * table[bidx[1]][im_pad.at<uchar>(i, j)]);
			}
			else if (i >= ((hnum - 1) * m + hm))
			{
				hbi = hnum - 1;
				wbi = (j - hm) / m;
				bidx[0] = hbi * wnum + wbi;
				bidx[1] = bidx[0] + 1;
				float p = (float)(j - (wbi * m + hm)) / m;
				float q = 1 - p;
				im_pad.at<uchar>(i, j) = (uchar)(q * table[bidx[0]][im_pad.at<uchar>(i, j)] + p * table[bidx[1]][im_pad.at<uchar>(i, j)]);
			}
			else if (j <= hm)
			{
				hbi = (i - hm) / m;
				//wbi = 0;
				bidx[0] = hbi * wnum;
				bidx[1] = bidx[0] + wnum;
				p = (float)(i - (hbi * m + hm)) / m;
				q = 1 - p;
				im_pad.at<uchar>(i, j) = (uchar)(q * table[bidx[0]][im_pad.at<uchar>(i, j)] + p * table[bidx[1]][im_pad.at<uchar>(i, j)]);
			}
			else if (j >= ((wnum - 1) * m + hm))
			{
				hbi = (i - hm) / m;
				wbi = wnum - 1;
				bidx[0] = hbi * wnum + wbi;
				bidx[1] = bidx[0] + wnum;
				p = (float)(i - (hbi * m + hm)) / m;
				q = 1 - p;
				im_pad.at<uchar>(i, j) = (uchar)(q * table[bidx[0]][im_pad.at<uchar>(i, j)] + p * table[bidx[1]][im_pad.at<uchar>(i, j)]);
			}
			// Double linear interpolation
			else
			{
				hbi = (i - hm) / m;
				wbi = (j - hm) / m;
				bidx[0] = hbi * wnum + wbi;
				bidx[1] = bidx[0] + 1;
				bidx[2] = bidx[0] + wnum;
				bidx[3] = bidx[1] + wnum;
				p = (float)(i - (hbi * m + hm)) / m;
				q = (float)(j - (wbi * m + hm)) / m;
				im_pad.at<uchar>(i, j) = (uchar)(
					(1 - p) * (1 - q) * table[bidx[0]][im_pad.at<uchar>(i, j)] +
					(1 - p) * q * table[bidx[1]][im_pad.at<uchar>(i, j)] +
					p * (1 - q) * table[bidx[2]][im_pad.at<uchar>(i, j)] +
					p * q * table[bidx[3]][im_pad.at<uchar>(i, j)]);
			}
			im_pad.at<uchar>(i, j) = im_pad.at<uchar>(i, j) + (im_pad.at<uchar>(i, j) << 8) + (im_pad.at<uchar>(i, j) << 16);
		}
	}
	im_pad.rowRange(top, top + h).colRange(left, left + w).copyTo(dst);

	delete[] table;
}
```

结果如下：

![nangongwan_clahe](../Data/histogram_equalization/nangongwan_clahe.png)

既不过分灰暗，也没有过分增强，效果可以说非常不错了！



## Opencv接口

其实opencv已经有接口实现全局直方图均衡化和限制对比度的自适应直方图均衡化：

```C++
// 全局直方图均衡化
cv::equalizeHist(src, dst);

// 限制对比度的自适应直方图均衡化
// @param clip_limit: double，限制对比度的因子
// @param size: cv::Size，图像分成网格的尺寸
cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE(clip_limit, size);
clahe->apply(src, dst);
```



最后还有一个问题是，直方图均衡化通常来说都是对单通道图像进行的，如果对多通道图像的每个通道分别进行均衡化，可能会出现一些色彩被增强得过分鲜艳的情况。比如：

原图：

![nangongwan](../Data/histogram_equalization/nangongwan.jpg)

对R、G、B个通道分别进行均衡化：

![nangongwan_bgr](../Data/histogram_equalization/nangongwan_bgr.png)

只对HSV色彩空间下的V通道进行均衡化：

![nangongwan_bgr1](../Data/histogram_equalization/nangongwan_bgr1.png)



参考博客：

https://www.cnblogs.com/jsxyhelu/p/6435601.html